"""
Comprehensive exploration script for Google Vertex AI structured outputs.

This script tests various aspects of the Pydantic models with Vertex AI,
documenting quirks, limitations, and best practices.
"""

import json
import sys
from typing import Any
from structured_query_builder import *
from structured_query_builder.translator import translate_query


def print_section(title: str):
    """Print a section header."""
    print(f"\n{'='*80}")
    print(f" {title}")
    print('='*80)


def explore_schema_structure():
    """Explore the JSON schema structure generated by Pydantic."""
    print_section("Schema Structure Analysis")

    schema = Query.model_json_schema()

    print("\n1. Top-level schema properties:")
    print(f"   - Type: {schema.get('type')}")
    print(f"   - Required fields: {schema.get('required')}")
    print(f"   - Has $defs: {'$defs' in schema}")
    print(f"   - Has definitions: {'definitions' in schema}")

    defs_key = "$defs" if "$defs" in schema else "definitions"
    defs = schema.get(defs_key, {})

    print(f"\n2. Total number of model definitions: {len(defs)}")

    print("\n3. Expression types (discriminated unions):")
    expr_types = [
        "ColumnExpr", "BinaryArithmetic", "CompoundArithmetic",
        "AggregateExpr", "WindowExpr", "CaseExpr"
    ]
    for expr_type in expr_types:
        if expr_type in defs:
            props = defs[expr_type].get("properties", {})
            print(f"   ✓ {expr_type}")
            if "expr_type" in props:
                expr_type_def = props["expr_type"]
                print(f"     - Discriminator value: {expr_type_def.get('const') or expr_type_def.get('enum')}")
        else:
            print(f"   ✗ {expr_type} (missing)")

    print("\n4. Checking for recursive references...")
    recursive_refs = check_recursive_references(schema)
    if recursive_refs:
        print("   ⚠ Found potentially recursive references:")
        for ref in recursive_refs:
            print(f"     - {ref}")
    else:
        print("   ✓ No recursive references found (good for Vertex AI)")

    print("\n5. Schema depth analysis:")
    max_depth = calculate_schema_depth(schema)
    print(f"   - Maximum nesting depth: {max_depth}")
    print(f"   - Assessment: {'OK' if max_depth <= 5 else 'May be too deep'}")

    # Save schema to file for inspection
    with open("query_schema.json", "w") as f:
        json.dump(schema, f, indent=2)
    print("\n6. Full schema saved to 'query_schema.json'")


def check_recursive_references(schema: dict, path: str = "root", seen: set = None) -> list[str]:
    """Check for recursive references in schema."""
    if seen is None:
        seen = set()

    recursive = []

    if isinstance(schema, dict):
        if "$ref" in schema:
            ref = schema["$ref"]
            if ref in seen:
                recursive.append(f"{path} -> {ref}")
            else:
                seen.add(ref)

        for key, value in schema.items():
            recursive.extend(check_recursive_references(value, f"{path}.{key}", seen.copy()))

    elif isinstance(schema, list):
        for i, item in enumerate(schema):
            recursive.extend(check_recursive_references(item, f"{path}[{i}]", seen.copy()))

    return recursive


def calculate_schema_depth(obj: Any, current_depth: int = 0) -> int:
    """Calculate maximum nesting depth of schema."""
    if not isinstance(obj, (dict, list)):
        return current_depth

    if isinstance(obj, dict):
        if not obj:
            return current_depth
        return max(
            calculate_schema_depth(value, current_depth + 1)
            for value in obj.values()
        )
    else:  # list
        if not obj:
            return current_depth
        return max(
            calculate_schema_depth(item, current_depth + 1)
            for item in obj
        )


def explore_model_construction():
    """Test manual construction of various query types."""
    print_section("Model Construction Tests")

    test_queries = [
        ("Simple SELECT", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.vendor)),
                ColumnExpr(source=QualifiedColumn(column=Column.category)),
            ],
            from_=FromClause(table=Table.product_offers)
        )),

        ("Aggregate with GROUP BY", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.category)),
                AggregateExpr(
                    function=AggregateFunc.avg,
                    column=Column.regular_price,
                    alias="avg_price"
                )
            ],
            from_=FromClause(table=Table.product_offers),
            group_by=GroupByClause(columns=[Column.category])
        )),

        ("Window Function", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                ColumnExpr(source=QualifiedColumn(column=Column.regular_price)),
                WindowExpr(
                    function=WindowFunc.rank,
                    column=Column.regular_price,
                    partition_by=[Column.category],
                    order_by=[OrderByItem(column=Column.regular_price, direction=Direction.asc)],
                    alias="price_rank"
                )
            ],
            from_=FromClause(table=Table.product_offers)
        )),

        ("Computed Column", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                BinaryArithmetic(
                    left_column=Column.regular_price,
                    operator=ArithmeticOp.subtract,
                    right_column=Column.markdown_price,
                    alias="discount_amount"
                )
            ],
            from_=FromClause(table=Table.product_offers),
            where=WhereL1(
                groups=[
                    ConditionGroup(
                        conditions=[
                            SimpleCondition(
                                column=QualifiedColumn(column=Column.is_markdown),
                                operator=ComparisonOp.eq,
                                value=True
                            )
                        ],
                        logic=LogicOp.and_
                    )
                ],
                group_logic=LogicOp.and_
            )
        )),

        ("Self-Join (Competitor Comparison)", lambda: Query(
            select=[
                ColumnExpr(
                    source=QualifiedColumn(table_alias="ours", column=Column.regular_price),
                    alias="our_price"
                ),
                ColumnExpr(
                    source=QualifiedColumn(table_alias="theirs", column=Column.regular_price),
                    alias="competitor_price"
                ),
            ],
            from_=FromClause(
                table=Table.product_offers,
                table_alias="ours",
                joins=[
                    JoinSpec(
                        join_type=JoinType.inner,
                        table=Table.product_offers,
                        table_alias="theirs",
                        left_column=Column.product_match_id,
                        left_table_alias="ours",
                        right_column=Column.product_match_id
                    )
                ]
            )
        )),

        ("Subquery in WHERE", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                ColumnExpr(source=QualifiedColumn(column=Column.regular_price)),
            ],
            from_=FromClause(table=Table.product_offers),
            where=WhereL1(
                subquery_conditions=[
                    SubqueryCondition(
                        column=QualifiedColumn(column=Column.regular_price),
                        operator=ComparisonOp.gt,
                        subquery=ScalarSubquery(
                            table=Table.product_offers,
                            aggregate=AggregateExpr(
                                function=AggregateFunc.avg,
                                column=Column.regular_price,
                                alias="avg_price"
                            ),
                            where=WhereL0(
                                groups=[
                                    ConditionGroup(
                                        conditions=[
                                            SimpleCondition(
                                                column=QualifiedColumn(column=Column.category),
                                                operator=ComparisonOp.eq,
                                                value="electronics"
                                            )
                                        ],
                                        logic=LogicOp.and_
                                    )
                                ],
                                group_logic=LogicOp.and_
                            )
                        )
                    )
                ],
                group_logic=LogicOp.and_
            )
        )),

        ("CASE Expression", lambda: Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                CaseExpr(
                    whens=[
                        CaseWhen(
                            condition_column=Column.regular_price,
                            condition_operator=ComparisonOp.lt,
                            condition_value=50,
                            then_value="cheap"
                        ),
                        CaseWhen(
                            condition_column=Column.regular_price,
                            condition_operator=ComparisonOp.lt,
                            condition_value=100,
                            then_value="medium"
                        ),
                    ],
                    else_value="expensive",
                    alias="price_tier"
                )
            ],
            from_=FromClause(table=Table.product_offers)
        )),
    ]

    for i, (name, query_func) in enumerate(test_queries, 1):
        print(f"\n{i}. {name}")
        try:
            query = query_func()
            sql = translate_query(query)

            # Test serialization
            json_str = query.model_dump_json()
            reconstructed = Query.model_validate_json(json_str)

            print(f"   ✓ Model construction: OK")
            print(f"   ✓ JSON serialization: OK")
            print(f"   ✓ JSON deserialization: OK")
            print(f"   ✓ SQL translation: OK")
            print(f"\n   SQL Preview:")
            sql_lines = sql.split('\n')
            for line in sql_lines[:3]:
                print(f"   {line}")
            if len(sql_lines) > 3:
                remaining = len(sql_lines) - 3
                print(f"   ... ({remaining} more lines)")

        except Exception as e:
            print(f"   ✗ Failed: {e}")
            import traceback
            traceback.print_exc()


def explore_pricing_analyst_use_cases():
    """Test all pricing analyst use cases from the spec."""
    print_section("Pricing Analyst Use Cases Validation")

    use_cases = {
        "Average price by category": Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.category)),
                AggregateExpr(
                    function=AggregateFunc.avg,
                    column=Column.regular_price,
                    alias="avg_price"
                )
            ],
            from_=FromClause(table=Table.product_offers),
            group_by=GroupByClause(columns=[Column.category])
        ),

        "Products on markdown with discount %": Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                CompoundArithmetic(
                    inner_left_column=Column.regular_price,
                    inner_operator=ArithmeticOp.subtract,
                    inner_right_column=Column.markdown_price,
                    outer_operator=ArithmeticOp.divide,
                    outer_column=Column.regular_price,
                    alias="discount_pct"
                )
            ],
            from_=FromClause(table=Table.product_offers),
            where=WhereL1(
                groups=[
                    ConditionGroup(
                        conditions=[
                            SimpleCondition(
                                column=QualifiedColumn(column=Column.is_markdown),
                                operator=ComparisonOp.eq,
                                value=True
                            )
                        ],
                        logic=LogicOp.and_
                    )
                ],
                group_logic=LogicOp.and_
            )
        ),

        "Rank competitors by price per category": Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.vendor)),
                ColumnExpr(source=QualifiedColumn(column=Column.category)),
                ColumnExpr(source=QualifiedColumn(column=Column.regular_price)),
                WindowExpr(
                    function=WindowFunc.rank,
                    column=Column.regular_price,
                    partition_by=[Column.category],
                    order_by=[OrderByItem(column=Column.regular_price, direction=Direction.asc)],
                    alias="price_rank"
                )
            ],
            from_=FromClause(table=Table.product_offers)
        ),

        "Week-over-week price change": Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                ColumnExpr(source=QualifiedColumn(column=Column.regular_price)),
                ColumnExpr(source=QualifiedColumn(column=Column.created_at)),
                WindowExpr(
                    function=WindowFunc.lag,
                    column=Column.regular_price,
                    partition_by=[Column.vendor, Column.title],
                    order_by=[OrderByItem(column=Column.created_at, direction=Direction.asc)],
                    offset=1,
                    default_value=0,
                    alias="prev_price"
                )
            ],
            from_=FromClause(table=Table.product_offers)
        ),

        "Price tier classification": Query(
            select=[
                ColumnExpr(source=QualifiedColumn(column=Column.title)),
                ColumnExpr(source=QualifiedColumn(column=Column.regular_price)),
                CaseExpr(
                    whens=[
                        CaseWhen(
                            condition_column=Column.regular_price,
                            condition_operator=ComparisonOp.lt,
                            condition_value=50,
                            then_value="cheap"
                        ),
                        CaseWhen(
                            condition_column=Column.regular_price,
                            condition_operator=ComparisonOp.lt,
                            condition_value=100,
                            then_value="medium"
                        ),
                    ],
                    else_value="expensive",
                    alias="price_tier"
                )
            ],
            from_=FromClause(table=Table.product_offers)
        ),
    }

    for i, (use_case, query) in enumerate(use_cases.items(), 1):
        print(f"\n{i}. {use_case}")
        try:
            sql = translate_query(query)
            print(f"   ✓ Supported")
            print(f"\n   SQL:")
            for line in sql.split('\n'):
                print(f"   {line}")
        except Exception as e:
            print(f"   ✗ Failed: {e}")


def test_vertex_ai_compatibility():
    """Test specific Vertex AI compatibility requirements."""
    print_section("Vertex AI Compatibility Checks")

    print("\n1. Union type handling (discriminated unions)")
    schema = Query.model_json_schema()
    defs = schema.get("$defs", schema.get("definitions", {}))

    # Check if we have proper discriminators
    has_discriminators = True
    for expr_type in ["ColumnExpr", "BinaryArithmetic", "AggregateExpr"]:
        if expr_type in defs:
            props = defs[expr_type].get("properties", {})
            if "expr_type" not in props:
                has_discriminators = False
                print(f"   ✗ {expr_type} missing discriminator")

    if has_discriminators:
        print("   ✓ All expression types have discriminators")

    print("\n2. No recursive types")
    recursive_refs = check_recursive_references(schema)
    if not recursive_refs:
        print("   ✓ No recursive references found")
    else:
        print(f"   ✗ Found {len(recursive_refs)} recursive references")

    print("\n3. Optional fields properly marked")
    query_props = schema.get("properties", {})
    required = set(schema.get("required", []))

    optional_should_be = ["where", "group_by", "having", "order_by", "limit"]
    all_optional_ok = True
    for field in optional_should_be:
        if field in required:
            print(f"   ✗ {field} should be optional but is required")
            all_optional_ok = False

    if all_optional_ok:
        print("   ✓ All optional fields properly configured")

    print("\n4. Enum handling")
    # Check that enums are properly defined
    table_def = defs.get("Table", {})
    if "enum" in table_def:
        print(f"   ✓ Enums properly defined (Table has {len(table_def['enum'])} values)")
    else:
        print("   ✗ Enum definitions may be problematic")

    print("\n5. Field descriptions present")
    has_descriptions = all(
        "description" in prop
        for prop in query_props.values()
        if isinstance(prop, dict)
    )
    if has_descriptions:
        print("   ✓ All fields have descriptions (helps LLM understanding)")
    else:
        print("   ⚠ Some fields missing descriptions")


def main():
    """Run all exploration tests."""
    print("\n" + "="*80)
    print(" GOOGLE VERTEX AI STRUCTURED OUTPUT EXPLORATION")
    print("="*80)

    try:
        explore_schema_structure()
        explore_model_construction()
        explore_pricing_analyst_use_cases()
        test_vertex_ai_compatibility()

        print("\n" + "="*80)
        print(" EXPLORATION COMPLETE")
        print("="*80)
        print("\nNext steps:")
        print("1. Review query_schema.json for detailed schema structure")
        print("2. Test with actual Vertex AI credentials using:")
        print("   pytest structured_query_builder/tests/test_vertexai_integration.py -v")
        print("3. Check documentation for any Vertex AI-specific quirks")

    except Exception as e:
        print(f"\nExploration failed with error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
